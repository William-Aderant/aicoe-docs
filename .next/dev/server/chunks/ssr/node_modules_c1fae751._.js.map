{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,4HACRC,QAAQ,CAAC,YAAY,CAAEC,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/fumadocs-mdx/dist/runtime/server.js","sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-mdx/src/runtime/server.ts"],"sourcesContent":["import type { MetaData, PageData, Source, VirtualFile } from 'fumadocs-core/source';\nimport * as path from 'node:path';\nimport type { DocCollection, DocsCollection, MetaCollection } from '@/config';\nimport type { StandardSchemaV1 } from '@standard-schema/spec';\nimport type { CompiledMDXProperties } from '@/loaders/mdx/build-mdx';\nimport type { InternalTypeConfig, DocData, DocMethods, FileInfo, MetaMethods } from './types';\n\nexport type MetaCollectionEntry<Data> = Data & MetaMethods;\n\nexport type DocCollectionEntry<\n  Name extends string = string,\n  Frontmatter = unknown,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> = DocData & DocMethods & Frontmatter & TC['DocData'][Name];\n\nexport type AsyncDocCollectionEntry<\n  Name extends string = string,\n  Frontmatter = unknown,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> = {\n  load: () => Promise<DocData & TC['DocData'][Name]>;\n} & DocMethods &\n  Frontmatter;\n\nexport interface DocsCollectionEntry<\n  Name extends string = string,\n  Frontmatter extends PageData = PageData,\n  Meta extends MetaData = MetaData,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> {\n  docs: DocCollectionEntry<Name, Frontmatter, TC>[];\n  meta: MetaCollectionEntry<Meta>[];\n  toFumadocsSource: () => Source<{\n    pageData: DocCollectionEntry<Name, Frontmatter, TC>;\n    metaData: MetaCollectionEntry<Meta>;\n  }>;\n}\n\nexport interface AsyncDocsCollectionEntry<\n  Name extends string = string,\n  Frontmatter extends PageData = PageData,\n  Meta extends MetaData = MetaData,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> {\n  docs: AsyncDocCollectionEntry<Name, Frontmatter, TC>[];\n  meta: MetaCollectionEntry<Meta>[];\n  toFumadocsSource: () => Source<{\n    pageData: AsyncDocCollectionEntry<Name, Frontmatter, TC>;\n    metaData: MetaCollectionEntry<Meta>;\n  }>;\n}\n\ntype AwaitableGlobEntries<T> = Record<string, T | (() => Promise<T>)>;\n\nexport type ServerCreate<Config, TC extends InternalTypeConfig = InternalTypeConfig> = ReturnType<\n  typeof server<Config, TC>\n>;\n\nexport interface ServerOptions {\n  doc?: {\n    passthroughs?: string[];\n  };\n}\n\nexport function server<Config, TC extends InternalTypeConfig>(options: ServerOptions = {}) {\n  const { doc: { passthroughs: docPassthroughs = [] } = {} } = options;\n\n  function fileInfo(file: string, base: string): FileInfo {\n    if (file.startsWith('./')) {\n      file = file.slice(2);\n    }\n\n    return {\n      path: file,\n      fullPath: path.join(base, file),\n    };\n  }\n\n  function mapDocData(entry: CompiledMDXProperties): DocData {\n    const data: DocData = {\n      body: entry.default,\n      toc: entry.toc,\n      structuredData: entry.structuredData,\n      _exports: entry as unknown as Record<string, unknown>,\n    };\n\n    for (const key of docPassthroughs) {\n      // @ts-expect-error -- handle passthrough properties\n      data[key] = entry[key];\n    }\n\n    return data;\n  }\n\n  return {\n    async doc<Name extends keyof Config & string>(\n      _name: Name,\n      base: string,\n      glob: AwaitableGlobEntries<unknown>,\n    ) {\n      const out = await Promise.all(\n        Object.entries(glob).map(async ([k, v]) => {\n          const data: CompiledMDXProperties = typeof v === 'function' ? await v() : v;\n\n          return {\n            ...mapDocData(data),\n            ...(data.frontmatter as object),\n            ...createDocMethods(fileInfo(k, base), () => data),\n          } satisfies DocCollectionEntry;\n        }),\n      );\n\n      return out as unknown as Config[Name] extends\n        | DocCollection<infer Schema>\n        | DocsCollection<infer Schema>\n        ? DocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>[]\n        : never;\n    },\n    async docLazy<Name extends keyof Config & string>(\n      _name: Name,\n      base: string,\n      head: AwaitableGlobEntries<unknown>,\n      body: Record<string, () => Promise<unknown>>,\n    ) {\n      const out = await Promise.all(\n        Object.entries(head).map(async ([k, v]) => {\n          const data = typeof v === 'function' ? await v() : v;\n          const content = body[k] as () => Promise<CompiledMDXProperties>;\n\n          return {\n            ...data,\n            ...createDocMethods(fileInfo(k, base), content),\n            async load() {\n              return mapDocData(await content());\n            },\n          } satisfies AsyncDocCollectionEntry;\n        }),\n      );\n\n      return out as unknown as Config[Name] extends\n        | DocCollection<infer Schema>\n        | DocsCollection<infer Schema>\n        ? AsyncDocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>[]\n        : never;\n    },\n    async meta<Name extends keyof Config & string>(\n      _name: Name,\n      base: string,\n      glob: AwaitableGlobEntries<unknown>,\n    ) {\n      const out = await Promise.all(\n        Object.entries(glob).map(async ([k, v]) => {\n          const data = typeof v === 'function' ? await v() : v;\n\n          return {\n            info: fileInfo(k, base),\n            ...data,\n          } satisfies MetaCollectionEntry<unknown>;\n        }),\n      );\n\n      return out as unknown as Config[Name] extends\n        | MetaCollection<infer Schema>\n        | DocsCollection<StandardSchemaV1, infer Schema>\n        ? MetaCollectionEntry<StandardSchemaV1.InferOutput<Schema>>[]\n        : never;\n    },\n\n    async docs<Name extends keyof Config & string>(\n      name: Name,\n      base: string,\n      metaGlob: AwaitableGlobEntries<unknown>,\n      docGlob: AwaitableGlobEntries<unknown>,\n    ) {\n      const entry = {\n        docs: await this.doc(name, base, docGlob),\n        meta: await this.meta(name, base, metaGlob),\n        toFumadocsSource() {\n          return toFumadocsSource(this.docs, this.meta);\n        },\n      } satisfies DocsCollectionEntry;\n\n      return entry as Config[Name] extends DocsCollection<infer Page, infer Meta>\n        ? StandardSchemaV1.InferOutput<Page> extends PageData\n          ? StandardSchemaV1.InferOutput<Meta> extends MetaData\n            ? DocsCollectionEntry<\n                Name,\n                StandardSchemaV1.InferOutput<Page>,\n                StandardSchemaV1.InferOutput<Meta>,\n                TC\n              >\n            : never\n          : never\n        : never;\n    },\n    async docsLazy<Name extends keyof Config & string>(\n      name: Name,\n      base: string,\n      metaGlob: AwaitableGlobEntries<unknown>,\n      docHeadGlob: AwaitableGlobEntries<unknown>,\n      docBodyGlob: Record<string, () => Promise<unknown>>,\n    ) {\n      const entry = {\n        docs: await this.docLazy(name, base, docHeadGlob, docBodyGlob),\n        meta: await this.meta(name, base, metaGlob),\n        toFumadocsSource() {\n          return toFumadocsSource(this.docs, this.meta);\n        },\n      } satisfies AsyncDocsCollectionEntry;\n\n      return entry as Config[Name] extends DocsCollection<infer Page, infer Meta>\n        ? StandardSchemaV1.InferOutput<Page> extends PageData\n          ? StandardSchemaV1.InferOutput<Meta> extends MetaData\n            ? AsyncDocsCollectionEntry<\n                Name,\n                StandardSchemaV1.InferOutput<Page>,\n                StandardSchemaV1.InferOutput<Meta>,\n                TC\n              >\n            : never\n          : never\n        : never;\n    },\n  };\n}\n\nexport function toFumadocsSource<\n  Page extends DocMethods & PageData,\n  Meta extends MetaMethods & MetaData,\n>(\n  pages: Page[],\n  metas: Meta[],\n): Source<{\n  pageData: Page;\n  metaData: Meta;\n}> {\n  const files: VirtualFile<{\n    pageData: Page;\n    metaData: Meta;\n  }>[] = [];\n\n  for (const entry of pages) {\n    files.push({\n      type: 'page',\n      path: entry.info.path,\n      absolutePath: entry.info.fullPath,\n      data: entry,\n    });\n  }\n\n  for (const entry of metas) {\n    files.push({\n      type: 'meta',\n      path: entry.info.path,\n      absolutePath: entry.info.fullPath,\n      data: entry,\n    });\n  }\n\n  return {\n    files,\n  };\n}\n\nfunction createDocMethods(\n  info: FileInfo,\n  load: () => CompiledMDXProperties | Promise<CompiledMDXProperties>,\n): DocMethods {\n  return {\n    info,\n    async getText(type) {\n      if (type === 'raw') {\n        const fs = await import('node:fs/promises');\n\n        return (await fs.readFile(info.fullPath)).toString();\n      }\n\n      const data = await load();\n      if (typeof data._markdown !== 'string')\n        throw new Error(\n          \"getText('processed') requires `includeProcessedMarkdown` to be enabled in your collection config.\",\n        );\n      return data._markdown;\n    },\n    async getMDAST() {\n      const data = await load();\n\n      if (!data._mdast)\n        throw new Error(\n          'getMDAST() requires `includeMDAST` to be enabled in your collection config.',\n        );\n      return JSON.parse(data._mdast);\n    },\n  };\n}\n"],"names":["path","data: DocData","data: CompiledMDXProperties","files: VirtualFile<{\n    pageData: Page;\n    metaData: Meta;\n  }>[]"],"mappings":"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"}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/dist/chunk-C1JLJEPO.js"],"sourcesContent":["//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\nvar __exportAll = (all, symbols) => {\n\tlet target = {};\n\tfor (var name in all) {\n\t\t__defProp(target, name, {\n\t\t\tget: all[name],\n\t\t\tenumerable: true\n\t\t});\n\t}\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\treturn target;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") {\n\t\tfor (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\t\tkey = keys[i];\n\t\t\tif (!__hasOwnProp.call(to, key) && key !== except) {\n\t\t\t\t__defProp(to, key, {\n\t\t\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\nexport { __exportAll as n, __toESM as r, __commonJSMin as t };"],"names":[],"mappings":";;;;;;;;AAAA,0BAA0B;AAC1B,IAAI,WAAW,OAAO,MAAM;AAC5B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,mBAAmB,OAAO,wBAAwB;AACtD,IAAI,oBAAoB,OAAO,mBAAmB;AAClD,IAAI,eAAe,OAAO,cAAc;AACxC,IAAI,eAAe,OAAO,SAAS,CAAC,cAAc;AAClD,IAAI,gBAAgB,CAAC,IAAI,MAAQ,IAAM,CAAC,OAAO,GAAG,CAAC,MAAM;YAAE,SAAS,CAAC;QAAE,CAAC,EAAE,OAAO,EAAE,MAAM,IAAI,OAAO;AACpG,IAAI,cAAc,CAAC,KAAK;IACvB,IAAI,SAAS,CAAC;IACd,IAAK,IAAI,QAAQ,IAAK;QACrB,UAAU,QAAQ,MAAM;YACvB,KAAK,GAAG,CAAC,KAAK;YACd,YAAY;QACb;IACD;IACA,IAAI,SAAS;QACZ,UAAU,QAAQ,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;IACzD;IACA,OAAO;AACR;AACA,IAAI,cAAc,CAAC,IAAI,MAAM,QAAQ;IACpC,IAAI,QAAQ,OAAO,SAAS,YAAY,OAAO,SAAS,YAAY;QACnE,IAAK,IAAI,OAAO,kBAAkB,OAAO,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,IAAI,GAAG,IAAK;YACjF,MAAM,IAAI,CAAC,EAAE;YACb,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,QAAQ,QAAQ,QAAQ;gBAClD,UAAU,IAAI,KAAK;oBAClB,KAAK,CAAC,CAAC,IAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM;oBACjC,YAAY,CAAC,CAAC,OAAO,iBAAiB,MAAM,IAAI,KAAK,KAAK,UAAU;gBACrE;YACD;QACD;IACD;IACA,OAAO;AACR;AACA,IAAI,UAAU,CAAC,KAAK,YAAY,SAAW,CAAC,SAAS,OAAO,OAAO,SAAS,aAAa,QAAQ,CAAC,GAAG,YAAY,cAAc,CAAC,OAAO,CAAC,IAAI,UAAU,GAAG,UAAU,QAAQ,WAAW;QACrL,OAAO;QACP,YAAY;IACb,KAAK,QAAQ,IAAI","ignoreList":[0]}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/fumadocs-core/dist/path-D6M0ZQvO.js","sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/path.ts"],"sourcesContent":["export function basename(path: string, ext?: string): string {\n  const idx = path.lastIndexOf('/');\n\n  return path.substring(idx === -1 ? 0 : idx + 1, ext ? path.length - ext.length : path.length);\n}\n\nexport function extname(path: string): string {\n  const dotIdx = path.lastIndexOf('.');\n\n  if (dotIdx !== -1) {\n    return path.substring(dotIdx);\n  }\n\n  return '';\n}\n\nexport function dirname(path: string): string {\n  return path.split('/').slice(0, -1).join('/');\n}\n/**\n * Split path into segments, trailing/leading slashes are removed\n */\nexport function splitPath(path: string): string[] {\n  return path.split('/').filter((p) => p.length > 0);\n}\n\n/**\n * Resolve paths, slashes within the path will be ignored\n * @param paths - Paths to join\n * @example\n * ```\n * ['a','b'] // 'a/b'\n * ['/a'] // 'a'\n * ['a', '/b'] // 'a/b'\n * ['a', '../b/c'] // 'b/c'\n * ```\n */\nexport function joinPath(...paths: string[]): string {\n  const out = [];\n  const parsed = paths.flatMap(splitPath);\n\n  for (const seg of parsed) {\n    switch (seg) {\n      case '..':\n        out.pop();\n        break;\n      case '.':\n        break;\n      default:\n        out.push(seg);\n    }\n  }\n\n  return out.join('/');\n}\n\nexport function slash(path: string): string {\n  const isExtendedLengthPath = path.startsWith('\\\\\\\\?\\\\');\n\n  if (isExtendedLengthPath) {\n    return path;\n  }\n\n  return path.replaceAll('\\\\', '/');\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAgB,SAAS,IAAA,EAAc,GAAA,EAAsB;IAC3D,MAAM,MAAM,KAAK,WAAA,CAAY,IAAI;IAEjC,OAAO,KAAK,SAAA,CAAU,QAAQ,CAAA,IAAK,IAAI,MAAM,GAAG,MAAM,KAAK,MAAA,GAAS,IAAI,MAAA,GAAS,KAAK,MAAA,CAAO;;AAG/F,SAAgB,QAAQ,IAAA,EAAsB;IAC5C,MAAM,SAAS,KAAK,WAAA,CAAY,IAAI;IAEpC,IAAI,WAAW,CAAA,EACb,CAAA,OAAO,KAAK,SAAA,CAAU,OAAO;IAG/B,OAAO;;AAGT,SAAgB,QAAQ,IAAA,EAAsB;IAC5C,OAAO,KAAK,KAAA,CAAM,IAAI,CAAC,KAAA,CAAM,GAAG,CAAA,EAAG,CAAC,IAAA,CAAK,IAAI;;;;GAK/C,SAAgB,UAAU,IAAA,EAAwB;IAChD,OAAO,KAAK,KAAA,CAAM,IAAI,CAAC,MAAA,CAAA,CAAQ,IAAM,EAAE,MAAA,GAAS,EAAE;;;;;;;;;;;;GAcpD,SAAgB,SAAS,GAAG,KAAA,EAAyB;IACnD,MAAM,MAAM,EAAE;IACd,MAAM,SAAS,MAAM,OAAA,CAAQ,UAAU;IAEvC,KAAK,MAAM,OAAO,OAChB,OAAQ,KAAR;QACE,KAAK;YACH,IAAI,GAAA,EAAK;YACT;QACF,KAAK,IACH;YAAA;QACF,QACE;YAAA,IAAI,IAAA,CAAK,IAAI;;IAInB,OAAO,IAAI,IAAA,CAAK,IAAI;;AAGtB,SAAgB,MAAM,IAAA,EAAsB;IAG1C,IAF6B,KAAK,UAAA,CAAW,UAAU,CAGrD,CAAA,OAAO;IAGT,OAAO,KAAK,UAAA,CAAW,MAAM,IAAI"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/fumadocs-core/dist/source/plugins/slugs.js","sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/plugins/slugs.ts"],"sourcesContent":["import { basename, dirname, extname } from '@/source/path';\nimport type { ContentStoragePageFile } from '../storage/content';\nimport type { LoaderConfig, LoaderPlugin } from '../loader';\n\n/**\n * a function to generate slugs, return `undefined` to fallback to default generation.\n */\nexport type SlugFn<Config extends LoaderConfig = LoaderConfig> = (\n  file: ContentStoragePageFile<Config['source']>,\n) => string[] | undefined;\n\n/**\n * Generate slugs for pages if missing\n */\nexport function slugsPlugin<Config extends LoaderConfig = LoaderConfig>(\n  slugFn?: SlugFn<Config>,\n): LoaderPlugin<Config> {\n  function isIndex(file: string) {\n    return basename(file, extname(file)) === 'index';\n  }\n\n  return {\n    name: 'fumadocs:slugs',\n    transformStorage({ storage }) {\n      const indexFiles: string[] = [];\n      const taken = new Set<string>();\n\n      for (const path of storage.getFiles()) {\n        const file = storage.read(path);\n        if (!file || file.format !== 'page' || file.slugs) continue;\n\n        const customSlugs = slugFn?.(file);\n        // for custom slugs function, don't handle conflicting cases like `dir/index.mdx` vs `dir.mdx`\n        if (customSlugs === undefined && isIndex(path)) {\n          indexFiles.push(path);\n          continue;\n        }\n\n        file.slugs = customSlugs ?? getSlugs(path);\n        const key = file.slugs.join('/');\n        if (taken.has(key)) throw new Error(`Duplicated slugs: ${key}`);\n        taken.add(key);\n      }\n\n      for (const path of indexFiles) {\n        const file = storage.read(path);\n        if (file?.format !== 'page') continue;\n\n        file.slugs = getSlugs(path);\n        if (taken.has(file.slugs.join('/'))) file.slugs.push('index');\n      }\n    },\n  };\n}\n\n/**\n * Generate slugs from file data (e.g. frontmatter).\n *\n * @param key - the property name in file data to generate slugs, default to `slug`.\n */\nexport function slugsFromData<Config extends LoaderConfig = LoaderConfig>(\n  key = 'slug',\n): SlugFn<Config> {\n  return (file) => {\n    const k = key as keyof typeof file.data;\n\n    if (k in file.data && typeof file.data[k] === 'string') {\n      return file.data[k].split('/').filter((v) => v.length > 0);\n    }\n  };\n}\n\nconst GroupRegex = /^\\(.+\\)$/;\n\n/**\n * Convert file path into slugs, also encode non-ASCII characters, so they can work in pathname\n */\nexport function getSlugs(file: string): string[] {\n  const dir = dirname(file);\n  const name = basename(file, extname(file));\n  const slugs: string[] = [];\n\n  for (const seg of dir.split('/')) {\n    // filter empty names and file groups like (group_name)\n    if (seg.length > 0 && !GroupRegex.test(seg)) slugs.push(encodeURI(seg));\n  }\n\n  if (GroupRegex.test(name)) throw new Error(`Cannot use folder group in file names: ${file}`);\n\n  if (name !== 'index') {\n    slugs.push(encodeURI(name));\n  }\n\n  return slugs;\n}\n"],"names":["indexFiles: string[]","slugs: string[]"],"mappings":";;;;;;;;;;;;;GAcA,SAAgB,YACd,MAAA,EACsB;IACtB,SAAS,QAAQ,IAAA,EAAc;QAC7B,WAAO,iKAAA,EAAS,UAAM,iKAAA,EAAQ,KAAK,CAAC,KAAK;;IAG3C,OAAO;QACL,MAAM;QACN,kBAAiB,EAAE,OAAA,EAAA,EAAW;YAC5B,MAAMA,aAAuB,EAAE;YAC/B,MAAM,QAAA,aAAA,GAAQ,IAAI,KAAa;YAE/B,KAAK,MAAM,QAAQ,QAAQ,QAAA,EAAU,CAAE;gBACrC,MAAM,OAAO,QAAQ,IAAA,CAAK,KAAK;gBAC/B,IAAI,CAAC,QAAQ,KAAK,MAAA,KAAW,UAAU,KAAK,KAAA,CAAO,CAAA;gBAEnD,MAAM,cAAc,SAAS,KAAK;gBAElC,IAAI,gBAAgB,KAAA,KAAa,QAAQ,KAAK,EAAE;oBAC9C,WAAW,IAAA,CAAK,KAAK;oBACrB;;gBAGF,KAAK,KAAA,GAAQ,eAAe,SAAS,KAAK;gBAC1C,MAAM,MAAM,KAAK,KAAA,CAAM,IAAA,CAAK,IAAI;gBAChC,IAAI,MAAM,GAAA,CAAI,IAAI,CAAE,CAAA,MAAM,IAAI,MAAM,CAAA,kBAAA,EAAqB,KAAA,CAAM;gBAC/D,MAAM,GAAA,CAAI,IAAI;;YAGhB,KAAK,MAAM,QAAQ,WAAY;gBAC7B,MAAM,OAAO,QAAQ,IAAA,CAAK,KAAK;gBAC/B,IAAI,MAAM,WAAW,OAAQ,CAAA;gBAE7B,KAAK,KAAA,GAAQ,SAAS,KAAK;gBAC3B,IAAI,MAAM,GAAA,CAAI,KAAK,KAAA,CAAM,IAAA,CAAK,IAAI,CAAC,CAAE,CAAA,KAAK,KAAA,CAAM,IAAA,CAAK,QAAQ;;;KAGlE;;;;;;GAQH,SAAgB,cACd,MAAM,MAAA,EACU;IAChB,OAAA,CAAQ,SAAS;QACf,MAAM,IAAI;QAEV,IAAI,KAAK,KAAK,IAAA,IAAQ,OAAO,KAAK,IAAA,CAAK,EAAA,KAAO,SAC5C,CAAA,OAAO,KAAK,IAAA,CAAK,EAAA,CAAG,KAAA,CAAM,IAAI,CAAC,MAAA,CAAA,CAAQ,IAAM,EAAE,MAAA,GAAS,EAAE;;;AAKhE,MAAM,aAAa;;;GAKnB,SAAgB,SAAS,IAAA,EAAwB;IAC/C,MAAM,UAAM,iKAAA,EAAQ,KAAK;IACzB,MAAM,WAAO,iKAAA,EAAS,UAAM,iKAAA,EAAQ,KAAK,CAAC;IAC1C,MAAMC,QAAkB,EAAE;IAE1B,KAAK,MAAM,OAAO,IAAI,KAAA,CAAM,IAAI,CAE9B,IAAI,IAAI,MAAA,GAAS,KAAK,CAAC,WAAW,IAAA,CAAK,IAAI,CAAE,CAAA,MAAM,IAAA,CAAK,UAAU,IAAI,CAAC;IAGzE,IAAI,WAAW,IAAA,CAAK,KAAK,CAAE,CAAA,MAAM,IAAI,MAAM,CAAA,uCAAA,EAA0C,MAAA,CAAO;IAE5F,IAAI,SAAS,QACX,CAAA,MAAM,IAAA,CAAK,UAAU,KAAK,CAAC;IAG7B,OAAO"}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/fumadocs-core/dist/icon-5lVe3l-0.js","sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/plugins/icon.ts"],"sourcesContent":["import type { LoaderPlugin } from '@/source';\nimport type { ReactNode } from 'react';\nimport type * as PageTree from '@/page-tree/definitions';\n\nexport type IconResolver = (icon: string | undefined) => ReactNode;\n\nexport function iconPlugin(resolveIcon: IconResolver): LoaderPlugin {\n  function replaceIcon<T extends PageTree.Node>(node: T): T {\n    if (node.icon === undefined || typeof node.icon === 'string')\n      node.icon = resolveIcon(node.icon);\n\n    return node;\n  }\n\n  return {\n    name: 'fumadocs:icon',\n    transformPageTree: {\n      file: replaceIcon,\n      folder: replaceIcon,\n      separator: replaceIcon,\n    },\n  };\n}\n"],"names":[],"mappings":";;;;;AAMA,SAAgB,WAAW,WAAA,EAAyC;IAClE,SAAS,YAAqC,IAAA,EAAY;QACxD,IAAI,KAAK,IAAA,KAAS,KAAA,KAAa,OAAO,KAAK,IAAA,KAAS,SAClD,CAAA,KAAK,IAAA,GAAO,YAAY,KAAK,IAAA,CAAK;QAEpC,OAAO;;IAGT,OAAO;QACL,MAAM;QACN,mBAAmB;YACjB,MAAM;YACN,QAAQ;YACR,WAAW;SACZ;KACF"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/fumadocs-core/dist/source/index.js","sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/source.ts","file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/storage/file-system.ts","file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/storage/content.ts","file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/page-tree/transformer-fallback.ts","file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/page-tree/builder.ts","file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/loader.ts"],"sourcesContent":["export interface Source<Config extends SourceConfig = SourceConfig> {\n  files: VirtualFile<Config>[];\n}\n\nexport interface SourceConfig {\n  pageData: PageData;\n  metaData: MetaData;\n}\n\nexport interface MetaData {\n  icon?: string | undefined;\n  title?: string | undefined;\n  root?: boolean | undefined;\n  pages?: string[] | undefined;\n  defaultOpen?: boolean | undefined;\n  collapsible?: boolean | undefined;\n\n  description?: string | undefined;\n}\n\nexport interface PageData {\n  icon?: string | undefined;\n  title?: string;\n  description?: string | undefined;\n}\n\nexport type VirtualFile<Config extends SourceConfig = SourceConfig> =\n  | VirtualPage<Config['pageData']>\n  | VirtualMeta<Config['metaData']>;\n\ninterface BaseVirtualFile {\n  /**\n   * Virtualized path (relative to content directory)\n   *\n   * @example `docs/page.mdx`\n   */\n  path: string;\n\n  /**\n   * Absolute path of the file\n   */\n  absolutePath?: string;\n}\n\ninterface VirtualPage<Data extends PageData> extends BaseVirtualFile {\n  type: 'page';\n  /**\n   * Specified Slugs for page\n   */\n  slugs?: string[];\n  data: Data;\n}\n\ninterface VirtualMeta<Data extends MetaData> extends BaseVirtualFile {\n  type: 'meta';\n  data: Data;\n}\n\nexport type _ConfigUnion_<T extends Record<string, Source>> = {\n  [K in keyof T]: T[K] extends Source<infer Config>\n    ? {\n        pageData: Config['pageData'] & { type: K };\n        metaData: Config['metaData'] & { type: K };\n      }\n    : never;\n}[keyof T];\n\nexport function multiple<T extends Record<string, Source>>(sources: T) {\n  const out: Source<_ConfigUnion_<T>> = { files: [] };\n\n  for (const [type, source] of Object.entries(sources)) {\n    for (const file of source.files) {\n      out.files.push({\n        ...file,\n        data: {\n          ...file.data,\n          type,\n        },\n      });\n    }\n  }\n\n  return out;\n}\n\nexport function source<Page extends PageData, Meta extends MetaData>(config: {\n  pages: VirtualPage<Page>[];\n  metas: VirtualMeta<Meta>[];\n}): Source<{\n  pageData: Page;\n  metaData: Meta;\n}> {\n  return {\n    files: [...config.pages, ...config.metas],\n  };\n}\n\nexport interface _SourceUpdate_<Config extends SourceConfig> {\n  files: <Page extends PageData, Meta extends MetaData>(\n    fn: (files: VirtualFile<Config>[]) => (VirtualPage<Page> | VirtualMeta<Meta>)[],\n  ) => _SourceUpdate_<{\n    pageData: Page;\n    metaData: Meta;\n  }>;\n  page: <V extends PageData>(\n    fn: (page: VirtualPage<Config['pageData']>) => VirtualPage<V>,\n  ) => _SourceUpdate_<{\n    pageData: V;\n    metaData: Config['metaData'];\n  }>;\n\n  meta: <V extends MetaData>(\n    fn: (meta: VirtualMeta<Config['metaData']>) => VirtualMeta<V>,\n  ) => _SourceUpdate_<{\n    pageData: Config['pageData'];\n    metaData: V;\n  }>;\n  build: () => Source<Config>;\n}\n\n/**\n * update a source object in-place.\n */\nexport function update<Config extends SourceConfig>(\n  source: Source<Config>,\n): _SourceUpdate_<Config> {\n  return {\n    files(fn) {\n      source.files = fn(source.files);\n      return this as _SourceUpdate_<never>;\n    },\n    page(fn) {\n      for (let i = 0; i < source.files.length; i++) {\n        const file = source.files[i];\n        if (file.type === 'page') source.files[i] = fn(file);\n      }\n\n      return this as _SourceUpdate_<never>;\n    },\n    meta(fn) {\n      for (let i = 0; i < source.files.length; i++) {\n        const file = source.files[i];\n        if (file.type === 'meta') source.files[i] = fn(file);\n      }\n\n      return this as _SourceUpdate_<never>;\n    },\n    build() {\n      return source;\n    },\n  };\n}\n","import { dirname, splitPath } from '../path';\n\n/**\n * In memory file system.\n */\nexport class FileSystem<File> {\n  files = new Map<string, File>();\n  folders = new Map<string, string[]>();\n\n  constructor(inherit?: FileSystem<File>) {\n    if (inherit) {\n      for (const [k, v] of inherit.folders) {\n        this.folders.set(k, v);\n      }\n\n      for (const [k, v] of inherit.files) {\n        this.files.set(k, v);\n      }\n    } else {\n      this.folders.set('', []);\n    }\n  }\n\n  read(path: string): File | undefined {\n    return this.files.get(path);\n  }\n\n  /**\n   * get the direct children of folder (in virtual file path)\n   */\n  readDir(path: string): string[] | undefined {\n    return this.folders.get(path);\n  }\n\n  write(path: string, file: File): void {\n    if (!this.files.has(path)) {\n      const dir = dirname(path);\n      this.makeDir(dir);\n      this.readDir(dir)?.push(path);\n    }\n\n    this.files.set(path, file);\n  }\n\n  /**\n   * Delete files at specified path.\n   *\n   * @param path - the target path.\n   * @param [recursive=false] - if set to `true`, it will also delete directories.\n   */\n  delete(path: string, recursive = false): boolean {\n    if (this.files.delete(path)) return true;\n\n    if (recursive) {\n      const folder = this.folders.get(path);\n      if (!folder) return false;\n\n      this.folders.delete(path);\n      for (const child of folder) {\n        this.delete(child);\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  getFiles(): string[] {\n    return Array.from(this.files.keys());\n  }\n\n  makeDir(path: string): void {\n    const segments = splitPath(path);\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments.slice(0, i + 1).join('/');\n      if (this.folders.has(segment)) continue;\n\n      this.folders.set(segment, []);\n      this.folders.get(dirname(segment))!.push(segment);\n    }\n  }\n}\n","import { FileSystem } from '@/source/storage/file-system';\nimport { basename, dirname, joinPath, slash, splitPath } from '@/source/path';\nimport type { ResolvedLoaderConfig } from '../loader';\nimport type { SourceConfig } from '../source';\n\nexport type ContentStorage<Config extends SourceConfig = SourceConfig> = FileSystem<\n  ContentStorageFile<Config>\n>;\n\nexport type ContentStorageFile<Config extends SourceConfig = SourceConfig> =\n  | ContentStorageMetaFile<Config>\n  | ContentStoragePageFile<Config>;\n\nexport interface ContentStorageMetaFile<Config extends SourceConfig = SourceConfig> {\n  path: string;\n  absolutePath?: string;\n\n  format: 'meta';\n  data: Config['metaData'];\n}\n\nexport interface ContentStoragePageFile<Config extends SourceConfig = SourceConfig> {\n  path: string;\n  absolutePath?: string;\n\n  format: 'page';\n  slugs: string[];\n  data: Config['pageData'];\n}\n\nfunction isLocaleValid(locale: string) {\n  return locale.length > 0 && !/\\d+/.test(locale);\n}\n\nconst parsers = {\n  dir(path: string): [string, string?] {\n    const [locale, ...segs] = path.split('/');\n\n    if (locale && segs.length > 0 && isLocaleValid(locale)) return [segs.join('/'), locale];\n\n    return [path];\n  },\n  dot(path: string): [string, string?] {\n    const dir = dirname(path);\n    const base = basename(path);\n    const parts = base.split('.');\n    if (parts.length < 3) return [path];\n\n    const [locale] = parts.splice(parts.length - 2, 1);\n    if (!isLocaleValid(locale)) return [path];\n\n    return [joinPath(dir, parts.join('.')), locale];\n  },\n  none(path: string): [string, string?] {\n    return [path];\n  },\n};\n\n/**\n * @param defaultLanguage - language to use when i18n is not configured.\n * @returns a map of locale and its content storage.\n *\n * in the storage, locale codes are removed from file paths, hence the same file will have same file paths in every storage.\n */\nexport function buildContentStorage(\n  loaderConfig: ResolvedLoaderConfig,\n  defaultLanguage: string,\n): Record<string, ContentStorage> {\n  const {\n    source,\n    plugins = [],\n    i18n = {\n      defaultLanguage,\n      parser: 'none',\n      languages: [defaultLanguage],\n    },\n  } = loaderConfig;\n\n  const parser = parsers[i18n.parser ?? 'dot'];\n  const storages: Record<string, ContentStorage> = {};\n  const normalized = new Map<\n    string,\n    {\n      pathWithoutLocale: string;\n      file: ContentStorageFile;\n    }[]\n  >();\n\n  for (const inputFile of source.files) {\n    let file: ContentStorageFile;\n    if (inputFile.type === 'page') {\n      file = {\n        format: 'page',\n        path: normalizePath(inputFile.path),\n        // will be generated by the slugs plugin if unspecified\n        slugs: inputFile.slugs as string[],\n        data: inputFile.data,\n        absolutePath: inputFile.absolutePath,\n      };\n    } else {\n      file = {\n        format: 'meta',\n        path: normalizePath(inputFile.path),\n        absolutePath: inputFile.absolutePath,\n        data: inputFile.data,\n      };\n    }\n\n    const [pathWithoutLocale, locale = i18n.defaultLanguage] = parser(file.path);\n    const list = normalized.get(locale) ?? [];\n    list.push({\n      pathWithoutLocale,\n      file,\n    });\n    normalized.set(locale, list);\n  }\n\n  const fallbackLang =\n    i18n.fallbackLanguage !== null ? (i18n.fallbackLanguage ?? i18n.defaultLanguage) : null;\n\n  function scan(lang: string) {\n    if (storages[lang]) return;\n\n    let storage: ContentStorage;\n    if (fallbackLang && fallbackLang !== lang) {\n      scan(fallbackLang);\n      storage = new FileSystem(storages[fallbackLang]);\n    } else {\n      storage = new FileSystem();\n    }\n\n    for (const { pathWithoutLocale, file } of normalized.get(lang) ?? []) {\n      storage.write(pathWithoutLocale, file);\n    }\n\n    const context = {\n      storage,\n    };\n    for (const plugin of plugins) {\n      plugin.transformStorage?.(context);\n    }\n\n    storages[lang] = storage;\n  }\n\n  for (const lang of i18n.languages) scan(lang);\n  return storages;\n}\n\n/**\n * @param path - Relative path\n * @returns Normalized path, with no trailing/leading slashes\n * @throws Throws error if path starts with `./` or `../`\n */\nfunction normalizePath(path: string): string {\n  const segments = splitPath(slash(path));\n  if (segments[0] === '.' || segments[0] === '..')\n    throw new Error(\"It must not start with './' or '../'\");\n  return segments.join('/');\n}\n","import type { ContentStorage, PageTreeTransformer } from '@/source';\nimport { FileSystem } from '@/source';\n\nexport function transformerFallback(): PageTreeTransformer {\n  const addedFiles = new Set<string>();\n\n  return {\n    root(root) {\n      const isolatedStorage: ContentStorage = new FileSystem();\n\n      for (const file of this.storage.getFiles()) {\n        if (addedFiles.has(file)) continue;\n\n        const content = this.storage.read(file);\n        if (content) isolatedStorage.write(file, content);\n      }\n\n      if (isolatedStorage.getFiles().length === 0) return root;\n\n      root.fallback = this.builder.build(isolatedStorage, {\n        ...this.options,\n        id: `fallback-${root.$id ?? ''}`,\n        generateFallback: false,\n      });\n\n      addedFiles.clear();\n      return root;\n    },\n    file(node, file) {\n      if (file) addedFiles.add(file);\n\n      return node;\n    },\n    folder(node, _dir, metaPath) {\n      if (metaPath) addedFiles.add(metaPath);\n\n      return node;\n    },\n  };\n}\n","import type * as PageTree from '@/page-tree/definitions';\nimport type { LoaderConfig, ResolvedLoaderConfig } from '@/source/loader';\nimport type { ContentStorage } from '@/source/storage/content';\nimport { basename, extname, joinPath } from '@/source/path';\nimport { transformerFallback } from '@/source/page-tree/transformer-fallback';\nimport type { SourceConfig } from '../source';\n\nexport interface PageTreeBuilderContext<Config extends SourceConfig = SourceConfig> {\n  rootId: string;\n  generateNodeId: () => string;\n  options: PageTreeOptions;\n  transformers: PageTreeTransformer<Config>[];\n\n  builder: PageTreeBuilder;\n  storage: ContentStorage<Config>;\n  getUrl: ResolvedLoaderConfig['url'];\n\n  storages?: Record<string, ContentStorage<Config>>;\n  locale?: string;\n}\n\nexport interface PageTreeTransformer<Config extends SourceConfig = SourceConfig> {\n  file?: (\n    this: PageTreeBuilderContext<Config>,\n    node: PageTree.Item,\n    filePath?: string,\n  ) => PageTree.Item;\n  folder?: (\n    this: PageTreeBuilderContext<Config>,\n    node: PageTree.Folder,\n    folderPath: string,\n    metaPath?: string,\n  ) => PageTree.Folder;\n  separator?: (\n    this: PageTreeBuilderContext<Config>,\n    node: PageTree.Separator,\n  ) => PageTree.Separator;\n  root?: (this: PageTreeBuilderContext<Config>, node: PageTree.Root) => PageTree.Root;\n}\n\nexport interface PageTreeOptions<Config extends LoaderConfig = LoaderConfig> {\n  id?: string;\n  /**\n   * Remove references to the file path of original nodes (`$ref`)\n   *\n   * @defaultValue false\n   */\n  noRef?: boolean;\n  /**\n   * generate fallback page tree\n   *\n   * @defaultValue true\n   */\n  generateFallback?: boolean;\n\n  /**\n   * Additional page tree transformers to apply\n   */\n  transformers?: PageTreeTransformer<Config['source']>[];\n}\n\nexport interface PageTreeBuilder {\n  build: (storage: ContentStorage, options?: PageTreeOptions) => PageTree.Root;\n\n  buildI18n: (\n    storages: Record<string, ContentStorage>,\n    options?: PageTreeOptions,\n  ) => Record<string, PageTree.Root>;\n}\n\nconst group = /^\\((?<name>.+)\\)$/;\nconst link = /^(?<external>external:)?(?:\\[(?<icon>[^\\]]+)])?\\[(?<name>[^\\]]+)]\\((?<url>[^)]+)\\)$/;\nconst separator = /^---(?:\\[(?<icon>[^\\]]+)])?(?<name>.+)---|^---$/;\nconst rest = '...' as const;\nconst restReversed = 'z...a' as const;\nconst extractPrefix = '...';\nconst excludePrefix = '!';\n\nexport function createPageTreeBuilder(loaderConfig: ResolvedLoaderConfig): PageTreeBuilder {\n  const { plugins = [], url, pageTree: defaultOptions = {} } = loaderConfig;\n\n  return {\n    build(storage, options = defaultOptions) {\n      const key = '';\n      return this.buildI18n({ [key]: storage }, options)[key];\n    },\n    buildI18n(storages, options = defaultOptions) {\n      let nextId = 0;\n      const out: Record<string, PageTree.Root> = {};\n      const transformers: PageTreeTransformer[] = [];\n\n      if (options.transformers) {\n        transformers.push(...options.transformers);\n      }\n\n      for (const plugin of plugins) {\n        if (plugin.transformPageTree) transformers.push(plugin.transformPageTree);\n      }\n\n      if (options.generateFallback ?? true) {\n        transformers.push(transformerFallback());\n      }\n\n      for (const [locale, storage] of Object.entries(storages)) {\n        let rootId = locale.length === 0 ? 'root' : locale;\n        if (options.id) rootId = `${options.id}-${rootId}`;\n\n        out[locale] = createPageTreeBuilderUtils({\n          rootId,\n          transformers,\n          builder: this,\n          options,\n          getUrl: url,\n          locale,\n          storage,\n          storages,\n          generateNodeId() {\n            return '_' + nextId++;\n          },\n        }).root();\n      }\n\n      return out;\n    },\n  };\n}\n\nfunction createFlattenPathResolver(storage: ContentStorage) {\n  const map = new Map<string, string>();\n  const files = storage.getFiles();\n  for (const file of files) {\n    const content = storage.read(file)!;\n    const flattenPath = file.substring(0, file.length - extname(file).length);\n\n    map.set(flattenPath + '.' + content.format, file);\n  }\n\n  return (name: string, format: string) => {\n    return map.get(name + '.' + format) ?? name;\n  };\n}\n\nfunction createPageTreeBuilderUtils(ctx: PageTreeBuilderContext) {\n  const resolveFlattenPath = createFlattenPathResolver(ctx.storage);\n  const visitedPaths = new Set<string>();\n\n  function nextNodeId(localId = ctx.generateNodeId()) {\n    return `${ctx.rootId}:${localId}`;\n  }\n\n  return {\n    buildPaths(paths: string[], reversed = false): PageTree.Node[] {\n      const items: PageTree.Node[] = [];\n      const folders: PageTree.Folder[] = [];\n      const sortedPaths = paths.sort((a, b) => a.localeCompare(b) * (reversed ? -1 : 1));\n\n      for (const path of sortedPaths) {\n        const fileNode = this.file(path);\n        if (fileNode) {\n          if (basename(path, extname(path)) === 'index') items.unshift(fileNode);\n          else items.push(fileNode);\n\n          continue;\n        }\n\n        const dirNode = this.folder(path, false);\n        if (dirNode) folders.push(dirNode);\n      }\n\n      items.push(...folders);\n      return items;\n    },\n    resolveFolderItem(folderPath: string, item: string): PageTree.Node[] | '...' | 'z...a' {\n      if (item === rest || item === restReversed) return item;\n\n      let match = separator.exec(item);\n      if (match?.groups) {\n        let node: PageTree.Separator = {\n          $id: nextNodeId(),\n          type: 'separator',\n          icon: match.groups.icon,\n          name: match.groups.name,\n        };\n\n        for (const transformer of ctx.transformers) {\n          if (!transformer.separator) continue;\n          node = transformer.separator.call(ctx, node);\n        }\n\n        return [node];\n      }\n\n      match = link.exec(item);\n      if (match?.groups) {\n        const { icon, url, name, external } = match.groups;\n\n        let node: PageTree.Item = {\n          $id: nextNodeId(),\n          type: 'page',\n          icon,\n          name,\n          url,\n          external: external ? true : undefined,\n        };\n\n        for (const transformer of ctx.transformers) {\n          if (!transformer.file) continue;\n          node = transformer.file.call(ctx, node);\n        }\n\n        return [node];\n      }\n\n      const isExcept = item.startsWith(excludePrefix);\n      const isExtract = !isExcept && item.startsWith(extractPrefix);\n\n      let filename = item;\n      if (isExcept) {\n        filename = item.slice(excludePrefix.length);\n      } else if (isExtract) {\n        filename = item.slice(extractPrefix.length);\n      }\n\n      const path = resolveFlattenPath(joinPath(folderPath, filename), 'page');\n\n      if (isExcept) {\n        visitedPaths.add(path);\n        return [];\n      }\n\n      const dirNode = this.folder(path, false);\n      if (dirNode) {\n        return isExtract ? dirNode.children : [dirNode];\n      }\n\n      const fileNode = this.file(path);\n      return fileNode ? [fileNode] : [];\n    },\n    folder(folderPath: string, isGlobalRoot: boolean): PageTree.Folder | undefined {\n      const { storage, options, transformers } = ctx;\n      const files = storage.readDir(folderPath);\n      if (!files) return;\n\n      const metaPath = resolveFlattenPath(joinPath(folderPath, 'meta'), 'meta');\n      const indexPath = resolveFlattenPath(joinPath(folderPath, 'index'), 'page');\n\n      let meta = storage.read(metaPath);\n      if (meta && meta.format !== 'meta') meta = undefined;\n\n      const metadata = meta?.data ?? {};\n      const { root = isGlobalRoot, pages } = metadata;\n      let index: PageTree.Item | undefined;\n      let children: PageTree.Node[];\n\n      if (pages) {\n        const resolved = pages.flatMap<PageTree.Node | typeof rest | typeof restReversed>((item) =>\n          this.resolveFolderItem(folderPath, item),\n        );\n\n        if (!root && !visitedPaths.has(indexPath)) {\n          index = this.file(indexPath);\n        }\n\n        for (let i = 0; i < resolved.length; i++) {\n          const item = resolved[i];\n          if (item !== rest && item !== restReversed) continue;\n\n          const items = this.buildPaths(\n            files.filter((file) => !visitedPaths.has(file)),\n            item === restReversed,\n          );\n\n          resolved.splice(i, 1, ...items);\n          break;\n        }\n\n        children = resolved as PageTree.Node[];\n      } else {\n        if (!root && !visitedPaths.has(indexPath)) {\n          index = this.file(indexPath);\n        }\n\n        children = this.buildPaths(files.filter((file) => !visitedPaths.has(file)));\n      }\n\n      let node: PageTree.Folder = {\n        type: 'folder',\n        name:\n          metadata.title ??\n          index?.name ??\n          (() => {\n            const folderName = basename(folderPath);\n            return pathToName(group.exec(folderName)?.[1] ?? folderName);\n          })(),\n        icon: metadata.icon ?? index?.icon,\n        root: metadata.root,\n        defaultOpen: metadata.defaultOpen,\n        description: metadata.description,\n        collapsible: metadata.collapsible,\n        index,\n        children,\n        $id: nextNodeId(folderPath),\n        $ref:\n          !options.noRef && meta\n            ? {\n                metaFile: metaPath,\n              }\n            : undefined,\n      };\n\n      visitedPaths.add(folderPath);\n      for (const transformer of transformers) {\n        if (!transformer.folder) continue;\n        node = transformer.folder.call(ctx, node, folderPath, metaPath);\n      }\n\n      return node;\n    },\n    file(path: string): PageTree.Item | undefined {\n      const { options, getUrl, storage, locale, transformers } = ctx;\n\n      const page = storage.read(path);\n      if (page?.format !== 'page') return;\n\n      const { title, description, icon } = page.data;\n      let item: PageTree.Item = {\n        $id: nextNodeId(path),\n        type: 'page',\n        name: title ?? pathToName(basename(path, extname(path))),\n        description,\n        icon,\n        url: getUrl(page.slugs, locale),\n        $ref: !options.noRef\n          ? {\n              file: path,\n            }\n          : undefined,\n      };\n\n      visitedPaths.add(path);\n      for (const transformer of transformers) {\n        if (!transformer.file) continue;\n        item = transformer.file.call(ctx, item, path);\n      }\n\n      return item;\n    },\n    root(): PageTree.Root {\n      const folder = this.folder('', true)!;\n      let root: PageTree.Root = {\n        $id: ctx.rootId,\n        name: folder.name || 'Docs',\n        children: folder.children,\n      };\n\n      for (const transformer of ctx.transformers) {\n        if (!transformer.root) continue;\n        root = transformer.root.call(ctx, root);\n      }\n\n      return root;\n    },\n  };\n}\n\n/**\n * Get item name from file name\n *\n * @param name - file name\n */\nfunction pathToName(name: string): string {\n  const result = [];\n  for (const c of name) {\n    if (result.length === 0) result.push(c.toLocaleUpperCase());\n    else if (c === '-') result.push(' ');\n    else result.push(c);\n  }\n\n  return result.join('');\n}\n","import type * as PageTree from '@/page-tree/definitions';\nimport type { I18nConfig } from '@/i18n';\nimport { buildContentStorage, type ContentStorage } from './storage/content';\nimport { createPageTreeBuilder, type PageTreeOptions } from '@/source/page-tree/builder';\nimport { joinPath } from './path';\nimport { normalizeUrl } from '@/utils/normalize-url';\nimport { SlugFn, slugsPlugin } from '@/source/plugins/slugs';\nimport { iconPlugin, type IconResolver } from '@/source/plugins/icon';\nimport type { MetaData, PageData, Source, SourceConfig } from './source';\nimport { visit } from '@/page-tree/utils';\nimport path from 'node:path';\nimport type { PageTreeTransformer } from '@/source/page-tree/builder';\n\nexport interface LoaderConfig {\n  source: SourceConfig;\n  i18n: I18nConfig | undefined;\n}\n\nexport interface LoaderOptions<C extends LoaderConfig = LoaderConfig> {\n  baseUrl: string;\n  i18n?: C['i18n'];\n  url?: (slugs: string[], locale?: string) => string;\n\n  /**\n   * Additional options for page tree builder\n   */\n  pageTree?: PageTreeOptions<C>;\n\n  plugins?:\n    | LoaderPluginOption[]\n    | ((context: {\n        typedPlugin: (plugin: LoaderPlugin<C>) => LoaderPlugin;\n      }) => LoaderPluginOption[]);\n  icon?: IconResolver;\n  slugs?: SlugFn<C>;\n}\n\nexport interface ResolvedLoaderConfig {\n  source: Source;\n  url: (slugs: string[], locale?: string) => string;\n\n  plugins?: LoaderPlugin[];\n  pageTree?: PageTreeOptions;\n  i18n?: I18nConfig | undefined;\n}\n\ninterface SharedFileInfo {\n  /**\n   * Virtualized file path (relative to content directory)\n   *\n   * @example `docs/page.mdx`\n   */\n  path: string;\n\n  /**\n   * Absolute path of the file\n   */\n  absolutePath?: string;\n}\n\nexport interface Page<Data = PageData> extends SharedFileInfo {\n  slugs: string[];\n  url: string;\n  data: Data;\n\n  locale?: string | undefined;\n}\n\nexport interface Meta<Data = MetaData> extends SharedFileInfo {\n  data: Data;\n}\n\nexport interface LoaderOutput<Config extends LoaderConfig> {\n  pageTree: Config['i18n'] extends I18nConfig ? Record<string, PageTree.Root> : PageTree.Root;\n\n  getPageTree: (locale?: string) => PageTree.Root;\n  /**\n   * get referenced page from href, supported:\n   *\n   * - relative file paths, like `./my/page.mdx`.\n   * - generated page pathname, like `/docs/my/page`.\n   */\n  getPageByHref: (\n    href: string,\n    options?: {\n      language?: string;\n\n      /**\n       * resolve relative file paths in `href` from specified dirname, must be a virtual path.\n       */\n      dir?: string;\n    },\n  ) =>\n    | {\n        page: Page<Config['source']['pageData']>;\n        hash?: string;\n      }\n    | undefined;\n  /**\n   * resolve special hrefs in a page, including:\n   *\n   * - relative file paths, like `./my/page.mdx`.\n   */\n  resolveHref: (href: string, parent: Page<Config['source']['pageData']>) => string;\n\n  /**\n   * @internal\n   */\n  _i18n?: I18nConfig;\n\n  /**\n   * Get a list of pages from specified language\n   *\n   * @param language - If empty, list pages from all languages.\n   */\n  getPages: (language?: string) => Page<Config['source']['pageData']>[];\n\n  /**\n   * get each language and its pages, empty if i18n is not enabled.\n   */\n  getLanguages: () => {\n    language: string;\n    pages: Page<Config['source']['pageData']>[];\n  }[];\n\n  /**\n   * Get page with slugs, the slugs can also be URI encoded.\n   *\n   * @param language - If empty, the default language will be used\n   */\n  getPage: (\n    slugs: string[] | undefined,\n    language?: string,\n  ) => Page<Config['source']['pageData']> | undefined;\n\n  getNodePage: (\n    node: PageTree.Item,\n    language?: string,\n  ) => Page<Config['source']['pageData']> | undefined;\n\n  getNodeMeta: (\n    node: PageTree.Folder,\n    language?: string,\n  ) => Meta<Config['source']['metaData']> | undefined;\n\n  /**\n   * generate static params for Next.js SSG\n   *\n   * @param slug - customise parameter name for slugs\n   * @param lang - customise parameter name for lang\n   */\n  generateParams: <TSlug extends string = 'slug', TLang extends string = 'lang'>(\n    slug?: TSlug,\n    lang?: TLang,\n  ) => (Record<TSlug, string[]> & Record<TLang, string>)[];\n\n  /**\n   * serialize page tree for non-RSC environments\n   */\n  serializePageTree: (tree: PageTree.Root) => Promise<object>;\n}\n\nfunction indexPages(storages: Record<string, ContentStorage>, { url }: ResolvedLoaderConfig) {\n  const result = {\n    // (locale.slugs -> page)\n    pages: new Map<string, Page>(),\n    // (locale.path -> page)\n    pathToMeta: new Map<string, Meta>(),\n    // (locale.path -> meta)\n    pathToPage: new Map<string, Page>(),\n  };\n\n  for (const [lang, storage] of Object.entries(storages)) {\n    for (const filePath of storage.getFiles()) {\n      const item = storage.read(filePath)!;\n      const path = `${lang}.${filePath}`;\n\n      if (item.format === 'meta') {\n        result.pathToMeta.set(path, {\n          path: item.path,\n          absolutePath: item.absolutePath,\n          data: item.data,\n        });\n        continue;\n      }\n\n      const page: Page = {\n        absolutePath: item.absolutePath,\n        path: item.path,\n        url: url(item.slugs, lang),\n        slugs: item.slugs,\n        data: item.data,\n        locale: lang,\n      };\n      result.pathToPage.set(path, page);\n      result.pages.set(`${lang}.${page.slugs.join('/')}`, page);\n    }\n  }\n\n  return result;\n}\n\nexport function createGetUrl(baseUrl: string, i18n?: I18nConfig): ResolvedLoaderConfig['url'] {\n  const baseSlugs = baseUrl.split('/');\n\n  return (slugs, locale) => {\n    const hideLocale = i18n?.hideLocale ?? 'never';\n    let urlLocale: string | undefined;\n\n    if (hideLocale === 'never') {\n      urlLocale = locale;\n    } else if (hideLocale === 'default-locale' && locale !== i18n?.defaultLanguage) {\n      urlLocale = locale;\n    }\n\n    const paths = [...baseSlugs, ...slugs];\n    if (urlLocale) paths.unshift(urlLocale);\n\n    return `/${paths.filter((v) => v.length > 0).join('/')}`;\n  };\n}\n\nexport function loader<\n  Config extends SourceConfig,\n  I18n extends I18nConfig | undefined = undefined,\n>(\n  source: Source<Config>,\n  options: LoaderOptions<{\n    source: NoInfer<Config>;\n    i18n: I18n;\n  }>,\n): LoaderOutput<{\n  source: Config;\n  i18n: I18n;\n}>;\n\nexport function loader<\n  Config extends SourceConfig,\n  I18n extends I18nConfig | undefined = undefined,\n>(\n  options: LoaderOptions<{\n    source: NoInfer<Config>;\n    i18n: I18n;\n  }> & {\n    source: Source<Config>;\n  },\n): LoaderOutput<{\n  source: Config;\n  i18n: I18n;\n}>;\n\nexport function loader(\n  ...args:\n    | [\n        LoaderOptions & {\n          source: Source;\n        },\n      ]\n    | [Source, LoaderOptions]\n): LoaderOutput<LoaderConfig> {\n  const loaderConfig =\n    args.length === 2 ? resolveConfig(args[0], args[1]) : resolveConfig(args[0].source, args[0]);\n  const { i18n } = loaderConfig;\n  const defaultLanguage = i18n?.defaultLanguage ?? '';\n  const storages = buildContentStorage(loaderConfig, defaultLanguage);\n  const walker = indexPages(storages, loaderConfig);\n  const builder = createPageTreeBuilder(loaderConfig);\n  let pageTrees: Record<string, PageTree.Root> | undefined;\n  function getPageTrees() {\n    return (pageTrees ??= builder.buildI18n(storages));\n  }\n\n  return {\n    _i18n: i18n,\n    get pageTree() {\n      const trees = getPageTrees();\n\n      return i18n\n        ? (trees as unknown as LoaderOutput<LoaderConfig>['pageTree'])\n        : trees[defaultLanguage];\n    },\n    set pageTree(v) {\n      if (i18n) {\n        pageTrees = v as unknown as Record<string, PageTree.Root>;\n      } else {\n        pageTrees ??= {};\n        pageTrees[defaultLanguage] = v;\n      }\n    },\n    getPageByHref(href, { dir = '', language = defaultLanguage } = {}) {\n      const [value, hash] = href.split('#', 2);\n      let target;\n\n      if (value.startsWith('./')) {\n        const path = joinPath(dir, value);\n\n        target = walker.pathToPage.get(`${language}.${path}`);\n      } else {\n        target = this.getPages(language).find((item) => item.url === value);\n      }\n\n      if (target)\n        return {\n          page: target,\n          hash,\n        };\n    },\n    resolveHref(href, parent) {\n      if (href.startsWith('./')) {\n        const target = this.getPageByHref(href, {\n          dir: path.dirname(parent.path),\n          language: parent.locale,\n        });\n\n        if (target) {\n          return target.hash ? `${target.page.url}#${target.hash}` : target.page.url;\n        }\n      }\n\n      return href;\n    },\n    getPages(language) {\n      const pages: Page[] = [];\n\n      for (const [key, value] of walker.pages.entries()) {\n        if (language === undefined || key.startsWith(`${language}.`)) {\n          pages.push(value);\n        }\n      }\n\n      return pages;\n    },\n    getLanguages() {\n      const list: {\n        language: string;\n        pages: Page[];\n      }[] = [];\n\n      if (!i18n) return list;\n      for (const language of i18n.languages) {\n        list.push({\n          language,\n          pages: this.getPages(language),\n        });\n      }\n\n      return list;\n    },\n    // the slugs plugin generates encoded slugs by default.\n    // we can assume page slugs are always URI encoded.\n    getPage(slugs = [], language = defaultLanguage) {\n      // `slugs` is already decoded\n      let page = walker.pages.get(`${language}.${slugs.join('/')}`);\n      if (page) return page;\n\n      // `slugs` is URI encoded\n      page = walker.pages.get(`${language}.${slugs.map(decodeURI).join('/')}`);\n      if (page) return page;\n    },\n    getNodeMeta(node, language = defaultLanguage) {\n      const ref = node.$ref?.metaFile;\n      if (!ref) return;\n\n      return walker.pathToMeta.get(`${language}.${ref}`);\n    },\n    getNodePage(node, language = defaultLanguage) {\n      const ref = node.$ref?.file;\n      if (!ref) return;\n\n      return walker.pathToPage.get(`${language}.${ref}`);\n    },\n    getPageTree(locale = defaultLanguage) {\n      const trees = getPageTrees();\n      return trees[locale] ?? trees[defaultLanguage];\n    },\n    // @ts-expect-error -- ignore this\n    generateParams(slug, lang) {\n      if (i18n) {\n        return this.getLanguages().flatMap((entry) =>\n          entry.pages.map((page) => ({\n            [slug ?? 'slug']: page.slugs,\n            [lang ?? 'lang']: entry.language,\n          })),\n        );\n      }\n\n      return this.getPages().map((page) => ({\n        [slug ?? 'slug']: page.slugs,\n      }));\n    },\n    async serializePageTree(tree: PageTree.Root): Promise<object> {\n      const { renderToString } = await import('react-dom/server.edge');\n\n      return visit(tree, (node) => {\n        node = { ...node };\n        if ('icon' in node && node.icon) {\n          node.icon = renderToString(node.icon);\n        }\n        if (node.name) {\n          node.name = renderToString(node.name);\n        }\n        if ('children' in node) {\n          node.children = [...node.children];\n        }\n\n        return node;\n      });\n    },\n  };\n}\n\nfunction resolveConfig(\n  source: Source,\n  { slugs, icon, plugins = [], baseUrl, url, ...base }: LoaderOptions,\n): ResolvedLoaderConfig {\n  let config: ResolvedLoaderConfig = {\n    ...base,\n    url: url ? (...args) => normalizeUrl(url(...args)) : createGetUrl(baseUrl, base.i18n),\n    source,\n    plugins: buildPlugins([\n      icon && iconPlugin(icon),\n      ...(typeof plugins === 'function'\n        ? plugins({\n            typedPlugin: (plugin) => plugin as unknown as LoaderPlugin,\n          })\n        : plugins),\n      slugsPlugin(slugs),\n    ]),\n  };\n\n  for (const plugin of config.plugins ?? []) {\n    const result = plugin.config?.(config);\n    if (result) config = result;\n  }\n\n  return config;\n}\n\nexport interface LoaderPlugin<Config extends LoaderConfig = LoaderConfig> {\n  name?: string;\n\n  /**\n   * Change the order of plugin:\n   * - `pre`: before normal plugins\n   * - `post`: after normal plugins\n   */\n  enforce?: 'pre' | 'post';\n\n  /**\n   * receive & replace loader options\n   */\n  config?: (config: ResolvedLoaderConfig) => ResolvedLoaderConfig | void | undefined;\n\n  /**\n   * transform the storage after loading\n   */\n  transformStorage?: (context: { storage: ContentStorage<Config['source']> }) => void;\n\n  /**\n   * transform the generated page tree\n   */\n  transformPageTree?: PageTreeTransformer<Config['source']>;\n}\n\nexport type LoaderPluginOption<Config extends LoaderConfig = LoaderConfig> =\n  | LoaderPlugin<Config>\n  | LoaderPluginOption<Config>[]\n  | undefined;\n\nconst priorityMap = {\n  pre: 1,\n  default: 0,\n  post: -1,\n};\n\nfunction buildPlugins(plugins: LoaderPluginOption[], sort = true): LoaderPlugin[] {\n  const flatten: LoaderPlugin[] = [];\n\n  for (const plugin of plugins) {\n    if (Array.isArray(plugin)) flatten.push(...buildPlugins(plugin, false));\n    else if (plugin) flatten.push(plugin);\n  }\n\n  if (sort)\n    return flatten.sort(\n      (a, b) => priorityMap[b.enforce ?? 'default'] - priorityMap[a.enforce ?? 'default'],\n    );\n  return flatten;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- infer types\nexport type InferPageType<Utils extends LoaderOutput<any>> =\n  Utils extends LoaderOutput<infer Config> ? Page<Config['source']['pageData']> : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- infer types\nexport type InferMetaType<Utils extends LoaderOutput<any>> =\n  Utils extends LoaderOutput<infer Config> ? Meta<Config['source']['metaData']> : never;\n"],"names":["out: Source<_ConfigUnion_<T>>","source","path","path","storages: Record<string, ContentStorage>","source","file: ContentStorageFile","storage: ContentStorage","isolatedStorage: ContentStorage","out: Record<string, PageTree.Root>","transformers: PageTreeTransformer[]","items: PageTree.Node[]","folders: PageTree.Folder[]","path","node: PageTree.Separator","node: PageTree.Item","index: PageTree.Item | undefined","children: PageTree.Node[]","node: PageTree.Folder","item: PageTree.Item","root: PageTree.Root","path","page: Page","urlLocale: string | undefined","pageTrees: Record<string, PageTree.Root> | undefined","pages: Page[]","list: {\n        language: string;\n        pages: Page[];\n      }[]","config: ResolvedLoaderConfig","flatten: LoaderPlugin[]"],"mappings":"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"}},
    {"offset": {"line": 1056, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/fumadocs-core/dist/source/plugins/lucide-icons.js","sources":["file:///Users/william.holden/Documents/GitHub/aicoe-docs/node_modules/fumadocs-core/src/source/plugins/lucide-icons.ts"],"sourcesContent":["import type { LoaderPlugin } from '@/source';\nimport { iconPlugin } from '@/source/plugins/icon';\nimport { icons } from 'lucide-react';\nimport { createElement } from 'react';\n\n/**\n * Convert icon names into Lucide Icons, requires `lucide-react` to be installed.\n */\nexport function lucideIconsPlugin(\n  options: {\n    defaultIcon?: keyof typeof icons;\n  } = {},\n): LoaderPlugin {\n  const { defaultIcon } = options;\n  return iconPlugin((icon = defaultIcon) => {\n    if (icon === undefined) return;\n    const Icon = icons[icon as keyof typeof icons];\n    if (!Icon) {\n      console.warn(`[lucide-icons-plugin] Unknown icon detected: ${icon}.`);\n      return;\n    }\n\n    return createElement(Icon);\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;GAQA,SAAgB,kBACd,UAEI,CAAA,CAAE,EACQ;IACd,MAAM,EAAE,WAAA,EAAA,GAAgB;IACxB,WAAO,oKAAA,EAAA,CAAY,OAAO,WAAA,KAAgB;QACxC,IAAI,SAAS,KAAA,EAAW,CAAA;QACxB,MAAM,OAAO,0MAAA,CAAM,KAAA;QACnB,IAAI,CAAC,MAAM;YACT,QAAQ,IAAA,CAAK,CAAA,6CAAA,EAAgD,KAAK,CAAA,CAAA,CAAG;YACrE;;QAGF,WAAO,sNAAA,EAAc,KAAK;MAC1B"}}]
}